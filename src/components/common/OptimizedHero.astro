---
import { decode } from 'blurhash';

interface Props {
  title?: string;
  description?: string;
  backgroundImage: string;
  className?: string;
  blurhash?: string;
}

const { 
  title, 
  description, 
  backgroundImage,
  className = "",
  blurhash = "L6PZfSi_.AyE_3t7t7R**0o#DgR4"
} = Astro.props;

// Generate blurhash on the server
let blurhashDataUrl = '';
try {
  const pixels = decode(blurhash, 32, 32);
  const canvas = new OffscreenCanvas(32, 32);
  const ctx = canvas.getContext('2d');
  const imageData = ctx.createImageData(32, 32);
  imageData.data.set(pixels);
  ctx.putImageData(imageData, 0, 0);
  blurhashDataUrl = canvas.convertToBlob().then(blob => URL.createObjectURL(blob));
} catch (error) {
  console.error('Error generating blurhash:', error);
}
---

<section 
  class={`relative h-[600px] md:h-[500px] flex items-center ${className}`}
>
  <!-- Blurhash background -->
  <div 
    class="absolute inset-0 bg-cover bg-center transition-opacity duration-500"
    style={blurhashDataUrl ? `background-image: url(${blurhashDataUrl})` : ''}
    data-blurhash={blurhash}
  >
  </div>

  <!-- Actual background image (loaded after interaction) -->
  <div 
    class="absolute inset-0 bg-cover bg-center opacity-0 transition-opacity duration-500"
    data-bg-image={backgroundImage}
  >
  </div>

  <!-- Overlay -->
  <div class="absolute inset-0 bg-gradient-to-b from-gray-900/70 to-gray-900/90"></div>

  <!-- Content -->
  <div class="relative container mx-auto px-4 py-16 text-white">
    {title && (
      <h1 class="text-4xl md:text-5xl lg:text-6xl font-bold mb-6">
        {title}
      </h1>
    )}
    {description && (
      <p class="text-xl text-gray-200 max-w-2xl">
        {description}
      </p>
    )}
    <slot />
  </div>
</section>

<script>
  import { decode } from 'blurhash';

  // Function to convert blurhash to data URL
  async function blurhashToDataURL(hash: string) {
    try {
      const pixels = decode(hash, 32, 32);
      const canvas = document.createElement('canvas');
      canvas.width = 32;
      canvas.height = 32;
      const ctx = canvas.getContext('2d');
      if (!ctx) return null;
      
      const imageData = ctx.createImageData(32, 32);
      imageData.data.set(pixels);
      ctx.putImageData(imageData, 0, 0);
      return canvas.toDataURL('image/jpeg');
    } catch (error) {
      console.error('Error generating blurhash:', error);
      return null;
    }
  }

  // Initialize blurhash backgrounds immediately
  document.querySelectorAll('[data-blurhash]').forEach(async element => {
    const hash = element.getAttribute('data-blurhash');
    if (hash) {
      const dataURL = await blurhashToDataURL(hash);
      if (dataURL) {
        element.style.backgroundImage = `url(${dataURL})`;
      }
    }
  });

  // Load hero images on interaction
  let hasInteracted = false;
  const loadImages = () => {
    if (hasInteracted) return;
    hasInteracted = true;
    
    const bgElements = document.querySelectorAll('[data-bg-image]');
    bgElements.forEach(element => {
      const bgImage = element.getAttribute('data-bg-image');
      if (bgImage) {
        // Ensure the image path starts with a forward slash
        const imagePath = bgImage.startsWith('/') ? bgImage : `/${bgImage}`;
        
        const img = new Image();
        img.onload = () => {
          element.style.backgroundImage = `url(${imagePath})`;
          element.style.opacity = '1';
          // Fade out blurhash
          const blurhashEl = element.previousElementSibling;
          if (blurhashEl) {
            blurhashEl.style.opacity = '0';
          }
        };
        img.src = imagePath;
      }
    });
  };

  // Add event listeners for user interaction
  ['mousemove', 'scroll', 'touchstart'].forEach(event => {
    window.addEventListener(event, loadImages, { once: true });
  });

  // Fallback: Load images after 3 seconds if no interaction
  setTimeout(loadImages, 3000);
</script> 